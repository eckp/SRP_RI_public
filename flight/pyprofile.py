#!/usr/bin/python3

'''
Provides a class with method that can be used to decorate functions to be profiled.
This means that starting and stopping times of the function are logged,
which can later be exported and plotted.
'''

import time
import csv


class Profiler:
    def __init__(self):
        self.events = []

    def profile(self, func):
        '''Returns a function that wraps the input argument with two calls,
that log the start and end time of the function to a general events list'''
        def wrapped(*args, **kwargs):
            try:
                objname = args[0].name+' '
            except:
                objname = ''
            self.events.append([time.time(), objname+func.__name__, 'start'])
            ret = func(*args, **kwargs)
            self.events.append([time.time(), objname+func.__name__, 'stop'])
            return ret
        return wrapped

    def save(self, out_file):
        '''Saves the events list to a csv file'''
        if not out_file.endswith('.csv'):
            out_file = out_file+'.csv'
        with open(out_file, 'w') as f:
            csv.writer(f).writerows(self.events)


class Analyser:
    def __init__(self, data_in):
        '''data_in should either be a list of events, as generated by the Profiler,
or it should be the path to a csv file, as written by the save function of the Profiler'''
        try:
            with open(data_in, 'r') as f:
                str_events = list(csv.reader(f))
            self.events = [(float(event[0]), *event[1:]) for event in str_events]
        except TypeError:
            self.events = data_in  # [[timestamp, function_name, start/stop], ...]
            assert isinstance(self.events, list)
        self.start = self.events[0][0]  # use first entry as t0 for plotting

        # dictionary of relative call times and duration per function
        self.data = {}  # {'function_name':[(time_start, duration), ...], ...}
        for row in self.events:
            if row[1] in self.data:
                if row[2] == 'start':
                    self.data[row[1]].append((row[0]-self.start, None))
                elif row[2] == 'stop':
                    self.data[row[1]][-1] = (self.data[row[1]][-1][0], row[0]-self.start-self.data[row[1]][-1][0])
            else:
                self.data[row[1]] = [(row[0]-self.start, None)]
        # filtering the data for finished and unfinished events
        self.finished_data = {k:[] for k in self.data.keys()}  # same as self.data
        self.unfinished_data = {k:[] for k in self.data.keys()}  # {'function_name': [time_start, ...]}
        for i, dataset in enumerate(self.data):
            for entry in self.data[dataset]:
                if None in entry:  # if the event is missing an end time, it is unfinished
                    self.unfinished_data[dataset].append(entry[0])
                else:
                    self.finished_data[dataset].append(entry)

    def plot(self, bar_height_fraction=0.9):
        '''Plots the timeline as a horizontal bar chart,
with unfinished events as triangles to indicate the start.'''
        # only import matplotlib if we actually need it, so we don't use it during flight
        global plt
        from matplotlib import pyplot as plt

        colors = plt.rcParams['axes.prop_cycle'].by_key()['color']
        plt.xlabel('Elapsed time [s]')
        plt.yticks(ticks=range(1, 2*len(self.data.keys())+1, 2), labels=self.data.keys())
        for i, dataset in enumerate(self.finished_data):
            color = colors[i%len(colors)]
            plt.scatter(self.unfinished_data[dataset], [2*i+1]*len(self.unfinished_data[dataset]), marker='>', c=color)
            plt.broken_barh(self.finished_data[dataset], (2*i+(1-bar_height_fraction), bar_height_fraction*2), facecolor=color)
        plt.show()

    def summary(self):
        '''Returns a summary of the data:
- total time
- total fraction of the total time any of the functions was running
- which fraction of the total time each function ran'''
        total_time = self.events[-1][0] - self.start
        fractions = {dataset: sum([entry[1] for entry in self.finished_data[dataset]])/total_time for dataset in self.data}
        total_fraction = sum(fractions.values())
        return total_time, total_fraction, fractions
